<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>MPack: Expect API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPack
   &#160;<span id="projectnumber">0.7</span>
   </div>
   <div id="projectbrief">A C encoding/decoding library for the MessagePack serialization format.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Expect API</div>  </div>
</div><!--header-->
<div class="contents">

<p>The MPack Expect API allows you to easily read MessagePack data when you expect it to follow a predefined schema.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic Number Functions</h2></td></tr>
<tr class="memitem:gab1310dc54c39ac7754ee62d635a82976"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab1310dc54c39ac7754ee62d635a82976">mpack_expect_u8</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab1310dc54c39ac7754ee62d635a82976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer.  <a href="#gab1310dc54c39ac7754ee62d635a82976">More...</a><br /></td></tr>
<tr class="separator:gab1310dc54c39ac7754ee62d635a82976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad267aebef43d94bc7891939d1fc2d51a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad267aebef43d94bc7891939d1fc2d51a">mpack_expect_u16</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad267aebef43d94bc7891939d1fc2d51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer.  <a href="#gad267aebef43d94bc7891939d1fc2d51a">More...</a><br /></td></tr>
<tr class="separator:gad267aebef43d94bc7891939d1fc2d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb728859e5944214324a23979fe0aa2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaccb728859e5944214324a23979fe0aa2">mpack_expect_u32</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaccb728859e5944214324a23979fe0aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer.  <a href="#gaccb728859e5944214324a23979fe0aa2">More...</a><br /></td></tr>
<tr class="separator:gaccb728859e5944214324a23979fe0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab2dbbc0830bc08f2e7ce851782ec06e5">mpack_expect_u64</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer.  <a href="#gab2dbbc0830bc08f2e7ce851782ec06e5">More...</a><br /></td></tr>
<tr class="separator:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728dc9cb317871bbf3360361a713d471"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga728dc9cb317871bbf3360361a713d471">mpack_expect_i8</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga728dc9cb317871bbf3360361a713d471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer.  <a href="#ga728dc9cb317871bbf3360361a713d471">More...</a><br /></td></tr>
<tr class="separator:ga728dc9cb317871bbf3360361a713d471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad8ef3886fd34471e00136a672b6cfbfa">mpack_expect_i16</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad8ef3886fd34471e00136a672b6cfbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer.  <a href="#gad8ef3886fd34471e00136a672b6cfbfa">More...</a><br /></td></tr>
<tr class="separator:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddca7f73951f581f0ddf03f6755322cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaddca7f73951f581f0ddf03f6755322cf">mpack_expect_i32</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaddca7f73951f581f0ddf03f6755322cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer.  <a href="#gaddca7f73951f581f0ddf03f6755322cf">More...</a><br /></td></tr>
<tr class="separator:gaddca7f73951f581f0ddf03f6755322cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad93d24fe9e68a1dd94054b70095ebcfb">mpack_expect_i64</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer.  <a href="#gad93d24fe9e68a1dd94054b70095ebcfb">More...</a><br /></td></tr>
<tr class="separator:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga49c6bea0c4d7e14a636d703ffe304264">mpack_expect_float</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga49c6bea0c4d7e14a636d703ffe304264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, returning the value as a float.  <a href="#ga49c6bea0c4d7e14a636d703ffe304264">More...</a><br /></td></tr>
<tr class="separator:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a47ece249cd4d6d795bf3211fde745"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga51a47ece249cd4d6d795bf3211fde745">mpack_expect_double</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga51a47ece249cd4d6d795bf3211fde745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, returning the value as a double.  <a href="#ga51a47ece249cd4d6d795bf3211fde745">More...</a><br /></td></tr>
<tr class="separator:ga51a47ece249cd4d6d795bf3211fde745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">mpack_expect_float_strict</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a float.  <a href="#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">More...</a><br /></td></tr>
<tr class="separator:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad676ff64ce7933cade0c85da8a83799f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad676ff64ce7933cade0c85da8a83799f">mpack_expect_double_strict</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad676ff64ce7933cade0c85da8a83799f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a double.  <a href="#gad676ff64ce7933cade0c85da8a83799f">More...</a><br /></td></tr>
<tr class="separator:gad676ff64ce7933cade0c85da8a83799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab217c0e2062b87129f948c6359c3825a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab217c0e2062b87129f948c6359c3825a">mpack_expect_uint</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab217c0e2062b87129f948c6359c3825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned int.  <a href="#gab217c0e2062b87129f948c6359c3825a">More...</a><br /></td></tr>
<tr class="separator:gab217c0e2062b87129f948c6359c3825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae81b9d03f80e49501c9b9a695489315f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gae81b9d03f80e49501c9b9a695489315f">mpack_expect_int</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gae81b9d03f80e49501c9b9a695489315f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed int.  <a href="#gae81b9d03f80e49501c9b9a695489315f">More...</a><br /></td></tr>
<tr class="separator:gae81b9d03f80e49501c9b9a695489315f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ranged Number Functions</h2></td></tr>
<tr class="memitem:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab3922088844e8cb301a6c2a5c5750d4f">mpack_expect_u8_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint8_t min_value, uint8_t max_value)</td></tr>
<tr class="memdesc:gab3922088844e8cb301a6c2a5c5750d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer, ensuring that it falls within the given range.  <a href="#gab3922088844e8cb301a6c2a5c5750d4f">More...</a><br /></td></tr>
<tr class="separator:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad6f984713bc3b24b044a99cd6f4e58b7">mpack_expect_u16_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint16_t min_value, uint16_t max_value)</td></tr>
<tr class="memdesc:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer, ensuring that it falls within the given range.  <a href="#gad6f984713bc3b24b044a99cd6f4e58b7">More...</a><br /></td></tr>
<tr class="separator:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">mpack_expect_u32_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t min_value, uint32_t max_value)</td></tr>
<tr class="memdesc:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer, ensuring that it falls within the given range.  <a href="#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">More...</a><br /></td></tr>
<tr class="separator:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7110dc658b713b292e9cafee3ccb7424"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7110dc658b713b292e9cafee3ccb7424">mpack_expect_u64_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint64_t min_value, uint64_t max_value)</td></tr>
<tr class="memdesc:ga7110dc658b713b292e9cafee3ccb7424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer, ensuring that it falls within the given range.  <a href="#ga7110dc658b713b292e9cafee3ccb7424">More...</a><br /></td></tr>
<tr class="separator:ga7110dc658b713b292e9cafee3ccb7424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa42508b6153a3531961eb69c38d48bbc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa42508b6153a3531961eb69c38d48bbc">mpack_expect_uint_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, unsigned int min_value, unsigned int max_value)</td></tr>
<tr class="memdesc:gaa42508b6153a3531961eb69c38d48bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned integer, ensuring that it falls within the given range.  <a href="#gaa42508b6153a3531961eb69c38d48bbc">More...</a><br /></td></tr>
<tr class="separator:gaa42508b6153a3531961eb69c38d48bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61459cbdd02c5b3db5292f9753a03ced"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga61459cbdd02c5b3db5292f9753a03ced">mpack_expect_u8_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint8_t max_value)</td></tr>
<tr class="memdesc:ga61459cbdd02c5b3db5292f9753a03ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer, ensuring that it is at most max_value.  <a href="#ga61459cbdd02c5b3db5292f9753a03ced">More...</a><br /></td></tr>
<tr class="separator:ga61459cbdd02c5b3db5292f9753a03ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga34cfd4d43ba388ff4f983b35c65c669a">mpack_expect_u16_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint16_t max_value)</td></tr>
<tr class="memdesc:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer, ensuring that it is at most max_value.  <a href="#ga34cfd4d43ba388ff4f983b35c65c669a">More...</a><br /></td></tr>
<tr class="separator:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4781e89d1712ae950b768362b8e98065"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4781e89d1712ae950b768362b8e98065">mpack_expect_u32_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t max_value)</td></tr>
<tr class="memdesc:ga4781e89d1712ae950b768362b8e98065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer, ensuring that it is at most max_value.  <a href="#ga4781e89d1712ae950b768362b8e98065">More...</a><br /></td></tr>
<tr class="separator:ga4781e89d1712ae950b768362b8e98065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gac5babd6ebf912abb4ed67ca8808f3ad0">mpack_expect_u64_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint64_t max_value)</td></tr>
<tr class="memdesc:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer, ensuring that it is at most max_value.  <a href="#gac5babd6ebf912abb4ed67ca8808f3ad0">More...</a><br /></td></tr>
<tr class="separator:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279a98fc2bb44cbf837fafc70df35bef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga279a98fc2bb44cbf837fafc70df35bef">mpack_expect_uint_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, unsigned int max_value)</td></tr>
<tr class="memdesc:ga279a98fc2bb44cbf837fafc70df35bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned integer, ensuring that it is at most max_value.  <a href="#ga279a98fc2bb44cbf837fafc70df35bef">More...</a><br /></td></tr>
<tr class="separator:ga279a98fc2bb44cbf837fafc70df35bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa553c386f7ad6d05423835d31a439461"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa553c386f7ad6d05423835d31a439461">mpack_expect_i8_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int8_t min_value, int8_t max_value)</td></tr>
<tr class="memdesc:gaa553c386f7ad6d05423835d31a439461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer, ensuring that it falls within the given range.  <a href="#gaa553c386f7ad6d05423835d31a439461">More...</a><br /></td></tr>
<tr class="separator:gaa553c386f7ad6d05423835d31a439461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4464418c0444854b3ab39785491a4b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6c4464418c0444854b3ab39785491a4b">mpack_expect_i16_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int16_t min_value, int16_t max_value)</td></tr>
<tr class="memdesc:ga6c4464418c0444854b3ab39785491a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer, ensuring that it falls within the given range.  <a href="#ga6c4464418c0444854b3ab39785491a4b">More...</a><br /></td></tr>
<tr class="separator:ga6c4464418c0444854b3ab39785491a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217f2065c5f039209f93cddbdbf01bee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga217f2065c5f039209f93cddbdbf01bee">mpack_expect_i32_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int32_t min_value, int32_t max_value)</td></tr>
<tr class="memdesc:ga217f2065c5f039209f93cddbdbf01bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer, ensuring that it falls within the given range.  <a href="#ga217f2065c5f039209f93cddbdbf01bee">More...</a><br /></td></tr>
<tr class="separator:ga217f2065c5f039209f93cddbdbf01bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7f7356f1e0638a076fac1a8db87f4f53">mpack_expect_i64_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int64_t min_value, int64_t max_value)</td></tr>
<tr class="memdesc:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer, ensuring that it falls within the given range.  <a href="#ga7f7356f1e0638a076fac1a8db87f4f53">More...</a><br /></td></tr>
<tr class="separator:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749d58ee5e884bce54b9767e7ee56c39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga749d58ee5e884bce54b9767e7ee56c39">mpack_expect_int_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int min_value, int max_value)</td></tr>
<tr class="memdesc:ga749d58ee5e884bce54b9767e7ee56c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed integer, ensuring that it falls within the given range.  <a href="#ga749d58ee5e884bce54b9767e7ee56c39">More...</a><br /></td></tr>
<tr class="separator:ga749d58ee5e884bce54b9767e7ee56c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1436e08a6cb710bf11dabff20188f67b"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1436e08a6cb710bf11dabff20188f67b">mpack_expect_i8_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int8_t max_value)</td></tr>
<tr class="memdesc:ga1436e08a6cb710bf11dabff20188f67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer, ensuring that it is at least zero and at most max_value.  <a href="#ga1436e08a6cb710bf11dabff20188f67b">More...</a><br /></td></tr>
<tr class="separator:ga1436e08a6cb710bf11dabff20188f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac3f09e7eb21aec1926aaff0ca37128"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4ac3f09e7eb21aec1926aaff0ca37128">mpack_expect_i16_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int16_t max_value)</td></tr>
<tr class="memdesc:ga4ac3f09e7eb21aec1926aaff0ca37128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer, ensuring that it is at least zero and at most max_value.  <a href="#ga4ac3f09e7eb21aec1926aaff0ca37128">More...</a><br /></td></tr>
<tr class="separator:ga4ac3f09e7eb21aec1926aaff0ca37128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9b77aa647947a1e47ab851c715cf6a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gacb9b77aa647947a1e47ab851c715cf6a">mpack_expect_i32_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int32_t max_value)</td></tr>
<tr class="memdesc:gacb9b77aa647947a1e47ab851c715cf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer, ensuring that it is at least zero and at most max_value.  <a href="#gacb9b77aa647947a1e47ab851c715cf6a">More...</a><br /></td></tr>
<tr class="separator:gacb9b77aa647947a1e47ab851c715cf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7354498073dfd3583db72591931d22a2"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7354498073dfd3583db72591931d22a2">mpack_expect_i64_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int64_t max_value)</td></tr>
<tr class="memdesc:ga7354498073dfd3583db72591931d22a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer, ensuring that it is at least zero and at most max_value.  <a href="#ga7354498073dfd3583db72591931d22a2">More...</a><br /></td></tr>
<tr class="separator:ga7354498073dfd3583db72591931d22a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a28a0a5daeeb9b4f10d2169d309f5eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7a28a0a5daeeb9b4f10d2169d309f5eb">mpack_expect_int_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int max_value)</td></tr>
<tr class="memdesc:ga7a28a0a5daeeb9b4f10d2169d309f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an int, ensuring that it is at least zero and at most max_value.  <a href="#ga7a28a0a5daeeb9b4f10d2169d309f5eb">More...</a><br /></td></tr>
<tr class="separator:ga7a28a0a5daeeb9b4f10d2169d309f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fffadf5032a669d582025f5131b53e2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0fffadf5032a669d582025f5131b53e2">mpack_expect_float_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, float min_value, float max_value)</td></tr>
<tr class="memdesc:ga0fffadf5032a669d582025f5131b53e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, ensuring that it falls within the given range and returning the value as a float.  <a href="#ga0fffadf5032a669d582025f5131b53e2">More...</a><br /></td></tr>
<tr class="separator:ga0fffadf5032a669d582025f5131b53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga63f44e3d23db5e24d86b0b714f9ff95b">mpack_expect_double_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, double min_value, double max_value)</td></tr>
<tr class="memdesc:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, ensuring that it falls within the given range and returning the value as a double.  <a href="#ga63f44e3d23db5e24d86b0b714f9ff95b">More...</a><br /></td></tr>
<tr class="separator:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Matching Number Functions</h2></td></tr>
<tr class="memitem:ga005303e0b2c39809fcd5172228fae282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga005303e0b2c39809fcd5172228fae282">mpack_expect_uint_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint64_t value)</td></tr>
<tr class="memdesc:ga005303e0b2c39809fcd5172228fae282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned integer, ensuring that it exactly matches the given value.  <a href="#ga005303e0b2c39809fcd5172228fae282">More...</a><br /></td></tr>
<tr class="separator:ga005303e0b2c39809fcd5172228fae282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8992b669afbaffee6ac8f336022611aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8992b669afbaffee6ac8f336022611aa">mpack_expect_int_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int64_t value)</td></tr>
<tr class="memdesc:ga8992b669afbaffee6ac8f336022611aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed integer, ensuring that it exactly matches the given value.  <a href="#ga8992b669afbaffee6ac8f336022611aa">More...</a><br /></td></tr>
<tr class="separator:ga8992b669afbaffee6ac8f336022611aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Other Basic Types</h2></td></tr>
<tr class="memitem:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gada69acbd6803f79cab7573ae9ebc37bd">mpack_expect_nil</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gada69acbd6803f79cab7573ae9ebc37bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil.  <a href="#gada69acbd6803f79cab7573ae9ebc37bd">More...</a><br /></td></tr>
<tr class="separator:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaeafa42ca3ae974494f127eb4b56ed8ae">mpack_expect_bool</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a bool.  <a href="#gaeafa42ca3ae974494f127eb4b56ed8ae">More...</a><br /></td></tr>
<tr class="separator:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfca446696881a598cc4f90892ded88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaadfca446696881a598cc4f90892ded88">mpack_expect_true</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaadfca446696881a598cc4f90892ded88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a bool, raising a mpack_error_type if it is not true.  <a href="#gaadfca446696881a598cc4f90892ded88">More...</a><br /></td></tr>
<tr class="separator:gaadfca446696881a598cc4f90892ded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa29ab364a7ae092e93a20b1a24744c0e">mpack_expect_false</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a bool, raising a mpack_error_type if it is not false.  <a href="#gaa29ab364a7ae092e93a20b1a24744c0e">More...</a><br /></td></tr>
<tr class="separator:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compound Types</h2></td></tr>
<tr class="memitem:ga44a2941b8e8ec379748c238fab52bda1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga44a2941b8e8ec379748c238fab52bda1">mpack_expect_map</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga44a2941b8e8ec379748c238fab52bda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map, returning its element count.  <a href="#ga44a2941b8e8ec379748c238fab52bda1">More...</a><br /></td></tr>
<tr class="separator:ga44a2941b8e8ec379748c238fab52bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d131161862c386e9f048ad93fb3d45"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa2d131161862c386e9f048ad93fb3d45">mpack_expect_map_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="memdesc:gaa2d131161862c386e9f048ad93fb3d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map with a number of elements in the given range, returning its element count.  <a href="#gaa2d131161862c386e9f048ad93fb3d45">More...</a><br /></td></tr>
<tr class="separator:gaa2d131161862c386e9f048ad93fb3d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d86c85877f94aa7b493aaa739c8849"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga36d86c85877f94aa7b493aaa739c8849">mpack_expect_map_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t max_count)</td></tr>
<tr class="memdesc:ga36d86c85877f94aa7b493aaa739c8849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map with a number of elements at most max_count, returning its element count.  <a href="#ga36d86c85877f94aa7b493aaa739c8849">More...</a><br /></td></tr>
<tr class="separator:ga36d86c85877f94aa7b493aaa739c8849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66c8c170be1b394b397ccc041d6c133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab66c8c170be1b394b397ccc041d6c133">mpack_expect_map_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:gab66c8c170be1b394b397ccc041d6c133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map of the exact size given.  <a href="#gab66c8c170be1b394b397ccc041d6c133">More...</a><br /></td></tr>
<tr class="separator:gab66c8c170be1b394b397ccc041d6c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaee3ac5d2ea0dc864b5898673a67c69ee">mpack_expect_map_or_nil</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t *count)</td></tr>
<tr class="memdesc:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of a map, returning whether a map was read and placing its number of key/value pairs in count.  <a href="#gaee3ac5d2ea0dc864b5898673a67c69ee">More...</a><br /></td></tr>
<tr class="separator:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aae8867b092afd5a2350d4701687b35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2aae8867b092afd5a2350d4701687b35">mpack_expect_map_max_or_nil</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t max_count, uint32_t *count)</td></tr>
<tr class="memdesc:ga2aae8867b092afd5a2350d4701687b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of a map with a number of elements at most max_count, returning whether a map was read and placing its number of key/value pairs in count.  <a href="#ga2aae8867b092afd5a2350d4701687b35">More...</a><br /></td></tr>
<tr class="separator:ga2aae8867b092afd5a2350d4701687b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18285492fd04458fb7ab0d151bea0402"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga18285492fd04458fb7ab0d151bea0402">mpack_expect_array</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga18285492fd04458fb7ab0d151bea0402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array, returning its element count.  <a href="#ga18285492fd04458fb7ab0d151bea0402">More...</a><br /></td></tr>
<tr class="separator:ga18285492fd04458fb7ab0d151bea0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0b7dd785576183e5444691c7d32b90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4c0b7dd785576183e5444691c7d32b90">mpack_expect_array_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="memdesc:ga4c0b7dd785576183e5444691c7d32b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array with a number of elements in the given range, returning its element count.  <a href="#ga4c0b7dd785576183e5444691c7d32b90">More...</a><br /></td></tr>
<tr class="separator:ga4c0b7dd785576183e5444691c7d32b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1599675ca83c5c03af8de220b9a826"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga3e1599675ca83c5c03af8de220b9a826">mpack_expect_array_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t max_count)</td></tr>
<tr class="memdesc:ga3e1599675ca83c5c03af8de220b9a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array with a number of elements at most max_count, returning its element count.  <a href="#ga3e1599675ca83c5c03af8de220b9a826">More...</a><br /></td></tr>
<tr class="separator:ga3e1599675ca83c5c03af8de220b9a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga799bb820a49f5a8a70e604466f8ab9b5">mpack_expect_array_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array of the exact size given.  <a href="#ga799bb820a49f5a8a70e604466f8ab9b5">More...</a><br /></td></tr>
<tr class="separator:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3202b0ed8916b311e2c225172afdb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2f3202b0ed8916b311e2c225172afdb3">mpack_expect_array_or_nil</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t *count)</td></tr>
<tr class="memdesc:ga2f3202b0ed8916b311e2c225172afdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of an array, returning whether an array was read and placing its number of elements in count.  <a href="#ga2f3202b0ed8916b311e2c225172afdb3">More...</a><br /></td></tr>
<tr class="separator:ga2f3202b0ed8916b311e2c225172afdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0ad5153a6d29bebf8251ba5beb1aaef3">mpack_expect_array_max_or_nil</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t max_count, uint32_t *count)</td></tr>
<tr class="memdesc:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of an array with a number of elements at most max_count, returning whether an array was read and placing its number of key/value pairs in count.  <a href="#ga0ad5153a6d29bebf8251ba5beb1aaef3">More...</a><br /></td></tr>
<tr class="separator:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7e69ee365f459dec5cdc3c797c7d0642">mpack_expect_array_alloc</a>(reader,  Type,  max_count,  out_count)</td></tr>
<tr class="memdesc:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array and allocates storage for it, placing its size in out_count.  <a href="#ga7e69ee365f459dec5cdc3c797c7d0642">More...</a><br /></td></tr>
<tr class="separator:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccad78065b48e2fd3c15c32e91927a75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaccad78065b48e2fd3c15c32e91927a75">mpack_expect_array_or_nil_alloc</a>(reader,  Type,  max_count,  out_count)</td></tr>
<tr class="memdesc:gaccad78065b48e2fd3c15c32e91927a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of an array and allocates storage for it, placing its size in out_count.  <a href="#gaccad78065b48e2fd3c15c32e91927a75">More...</a><br /></td></tr>
<tr class="separator:gaccad78065b48e2fd3c15c32e91927a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
String Functions</h2></td></tr>
<tr class="memitem:ga6baba88194988c9f423630052d59f7fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga6baba88194988c9f423630052d59f7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, returning its size in bytes.  <a href="#ga6baba88194988c9f423630052d59f7fd">More...</a><br /></td></tr>
<tr class="separator:ga6baba88194988c9f423630052d59f7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658205c994cf8fce528f4c8a3a957a14"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga658205c994cf8fce528f4c8a3a957a14">mpack_expect_str_buf</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t bufsize)</td></tr>
<tr class="memdesc:ga658205c994cf8fce528f4c8a3a957a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string of at most the given size, writing it into the given buffer and returning its size in bytes.  <a href="#ga658205c994cf8fce528f4c8a3a957a14">More...</a><br /></td></tr>
<tr class="separator:ga658205c994cf8fce528f4c8a3a957a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c44c450649514ee1a31e567d39f0bf0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8c44c450649514ee1a31e567d39f0bf0">mpack_expect_utf8</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t bufsize)</td></tr>
<tr class="memdesc:ga8c44c450649514ee1a31e567d39f0bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensuring it is a valid UTF-8 string and returning its size in bytes.  <a href="#ga8c44c450649514ee1a31e567d39f0bf0">More...</a><br /></td></tr>
<tr class="separator:ga8c44c450649514ee1a31e567d39f0bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5d6e47485092366b64d7667fc93916"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaea5d6e47485092366b64d7667fc93916">mpack_expect_str_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="memdesc:gaea5d6e47485092366b64d7667fc93916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, raising an error if its length is not at most the given number of bytes (not including any null-terminator.)  <a href="#gaea5d6e47485092366b64d7667fc93916">More...</a><br /></td></tr>
<tr class="separator:gaea5d6e47485092366b64d7667fc93916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2125706c0ccfa05074f2a0551fbf2cf1"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2125706c0ccfa05074f2a0551fbf2cf1">mpack_expect_str_length</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:ga2125706c0ccfa05074f2a0551fbf2cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, raising an error if its length is not exactly the given number of bytes (not including any null-terminator.)  <a href="#ga2125706c0ccfa05074f2a0551fbf2cf1">More...</a><br /></td></tr>
<tr class="separator:ga2125706c0ccfa05074f2a0551fbf2cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d720d03002423e764c55b9370d89caf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0d720d03002423e764c55b9370d89caf">mpack_expect_str_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:ga0d720d03002423e764c55b9370d89caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string with the given total maximum size, allocating storage for it.  <a href="#ga0d720d03002423e764c55b9370d89caf">More...</a><br /></td></tr>
<tr class="separator:ga0d720d03002423e764c55b9370d89caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7079e453f462184ada877d68816d59e3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7079e453f462184ada877d68816d59e3">mpack_expect_utf8_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:ga7079e453f462184ada877d68816d59e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string with the given total maximum size, allocating storage for it and ensuring it is valid UTF-8.  <a href="#ga7079e453f462184ada877d68816d59e3">More...</a><br /></td></tr>
<tr class="separator:ga7079e453f462184ada877d68816d59e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga3ceade6375ab699c1ef05ef9f5c2ff90">mpack_expect_str_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, const char *str, size_t length)</td></tr>
<tr class="memdesc:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string, ensuring it exactly matches the given string.  <a href="#ga3ceade6375ab699c1ef05ef9f5c2ff90">More...</a><br /></td></tr>
<tr class="separator:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the end.  <a href="#ga94489d03628c1fb1a3d0ac6971600fe8">More...</a><br /></td></tr>
<tr class="separator:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62be63032f3c84181eeed4609f0dddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga62be63032f3c84181eeed4609f0dddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensures it is a valid UTF-8 string without null characters, and adds a null-terminator at the end.  <a href="#ga62be63032f3c84181eeed4609f0dddb4">More...</a><br /></td></tr>
<tr class="separator:ga62be63032f3c84181eeed4609f0dddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab6d2d920a0ed7d39e251ac8d6f077998">mpack_expect_cstr_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize)</td></tr>
<tr class="memdesc:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it has no null-bytes, and adds a null-terminator at the end.  <a href="#gab6d2d920a0ed7d39e251ac8d6f077998">More...</a><br /></td></tr>
<tr class="separator:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5acb7f64d13ce1a09670377cbbbf68c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5acb7f64d13ce1a09670377cbbbf68c7"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_utf8_cstr_alloc</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize)</td></tr>
<tr class="separator:ga5acb7f64d13ce1a09670377cbbbf68c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a0891f890670e68efeaf1e0772d4b1"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga45a0891f890670e68efeaf1e0772d4b1">mpack_expect_cstr_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, const char *str)</td></tr>
<tr class="memdesc:ga45a0891f890670e68efeaf1e0772d4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string, ensuring it exactly matches the given null-terminated string.  <a href="#ga45a0891f890670e68efeaf1e0772d4b1">More...</a><br /></td></tr>
<tr class="separator:ga45a0891f890670e68efeaf1e0772d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Binary Data / Extension Functions</h2></td></tr>
<tr class="memitem:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5">mpack_expect_bin</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, returning its size in bytes.  <a href="#gadcf7fc94ae30ed5c3752291a0efd43c5">More...</a><br /></td></tr>
<tr class="separator:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2050120f7cc80ca7ef8748774cc80ed"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gac2050120f7cc80ca7ef8748774cc80ed">mpack_expect_bin_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="memdesc:gac2050120f7cc80ca7ef8748774cc80ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, raising an error if its length is not at most the given number of bytes.  <a href="#gac2050120f7cc80ca7ef8748774cc80ed">More...</a><br /></td></tr>
<tr class="separator:gac2050120f7cc80ca7ef8748774cc80ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8202406ef14871b82ee0b4f3a1da21"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gace8202406ef14871b82ee0b4f3a1da21">mpack_expect_bin_size</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:gace8202406ef14871b82ee0b4f3a1da21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, raising an error if its length is not exactly the given number of bytes.  <a href="#gace8202406ef14871b82ee0b4f3a1da21">More...</a><br /></td></tr>
<tr class="separator:gace8202406ef14871b82ee0b4f3a1da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga98004c26b9ebc1b80b4bdec5a1d4b093">mpack_expect_bin_buf</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a binary blob into the given buffer, returning its size in bytes.  <a href="#ga98004c26b9ebc1b80b4bdec5a1d4b093">More...</a><br /></td></tr>
<tr class="separator:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2745fe313f15c619a9a44f8dc79a3777"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2745fe313f15c619a9a44f8dc79a3777"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_bin_inplace</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="separator:ga2745fe313f15c619a9a44f8dc79a3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga513a9ce0e5bf78128d2d174bf1434538">mpack_expect_bin_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:ga513a9ce0e5bf78128d2d174bf1434538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a binary blob with the given total maximum size, allocating storage for it.  <a href="#ga513a9ce0e5bf78128d2d174bf1434538">More...</a><br /></td></tr>
<tr class="separator:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Special Functions</h2></td></tr>
<tr class="memitem:ga6e9c48430fa233615ec9b5439f9ed451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6e9c48430fa233615ec9b5439f9ed451">mpack_expect_tag</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#structmpack__tag__t">mpack_tag_t</a> tag)</td></tr>
<tr class="memdesc:ga6e9c48430fa233615ec9b5439f9ed451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a MessagePack object header (an MPack tag), expecting it to exactly match the given tag.  <a href="#ga6e9c48430fa233615ec9b5439f9ed451">More...</a><br /></td></tr>
<tr class="separator:ga6e9c48430fa233615ec9b5439f9ed451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The MPack Expect API allows you to easily read MessagePack data when you expect it to follow a predefined schema. </p>
<p>The main purpose of the Expect API is convenience, so the API is lax. It allows overlong / inefficiently encoded sequences, and it automatically converts between similar types where there is no loss of precision (unless otherwise noted.) It will convert from unsigned to signed or from float to double for example.</p>
<p>When using any of the expect functions, if the type or value of what was read does not match what is expected, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7e69ee365f459dec5cdc3c797c7d0642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_expect_array_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array and allocates storage for it, placing its size in out_count. </p>
<p>A number of objects follow equal to the element count of the array. You must call <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> when done (even if the element count is zero.)</p>
<p>If an error occurs, NULL is returned and the reader is placed in an error state.</p>
<p>If the count is zero, NULL is returned. This does not indicate error. You should not check the return value for NULL to check for errors; only check the reader's error state.</p>
<p>The allocated array must be freed with MPACK_FREE() (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaccad78065b48e2fd3c15c32e91927a75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_expect_array_or_nil_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of an array and allocates storage for it, placing its size in out_count. </p>
<p>A number of objects follow equal to the element count of the array if a non-empty array was read.</p>
<p>If an error occurs, NULL is returned and the reader is placed in an error state.</p>
<p>If a nil node was read, NULL is returned. If an empty array was read, <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06" title="Finishes reading an array. ">mpack_done_array()</a> is called automatically and NULL is returned. These do not indicate error. You should not check the return value for NULL to check for errors; only check the reader's error state.</p>
<p>The allocated array must be freed with MPACK_FREE() (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="section warning"><dt>Warning</dt><dd>You must call <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> if and only if a non-zero element count is read. This function does not differentiate between nil and an empty array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga18285492fd04458fb7ab0d151bea0402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read. </p>

</div>
</div>
<a class="anchor" id="ga799bb820a49f5a8a70e604466f8ab9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_array_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array of the exact size given. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not match the given count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e1599675ca83c5c03af8de220b9a826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array with a number of elements at most max_count, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<p>Zero is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ad5153a6d29bebf8251ba5beb1aaef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_array_max_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of an array with a number of elements at most max_count, returning whether an array was read and placing its number of key/value pairs in count. </p>
<p>If an array was read, a number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> should also be called once all elements have been read (only if an array was read.)</p>
<dl class="section return"><dt>Returns</dt><dd>true if an array was read successfully; false if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f3202b0ed8916b311e2c225172afdb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_array_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of an array, returning whether an array was read and placing its number of elements in count. </p>
<p>If an array was read, a number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> should also be called once all elements have been read (only if an array was read.)</p>
<dl class="section return"><dt>Returns</dt><dd>true if an array was read successfully; false if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c0b7dd785576183e5444691c7d32b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array with a number of elements in the given range, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<p>min_count is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadcf7fc94ae30ed5c3752291a0efd43c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, returning its size in bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob. </p>

</div>
</div>
<a class="anchor" id="ga513a9ce0e5bf78128d2d174bf1434538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_bin_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a binary blob with the given total maximum size, allocating storage for it. </p>

</div>
</div>
<a class="anchor" id="ga98004c26b9ebc1b80b4bdec5a1d4b093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_bin_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a binary blob into the given buffer, returning its size in bytes. </p>
<p>For compatibility, this will accept if the underlying type is string or binary (since in MessagePack 1.0, strings and binary data were combined under the "raw" type which became string in 1.1.) </p>

</div>
</div>
<a class="anchor" id="gac2050120f7cc80ca7ef8748774cc80ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED uint32_t mpack_expect_bin_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, raising an error if its length is not at most the given number of bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="gace8202406ef14871b82ee0b4f3a1da21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED void mpack_expect_bin_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, raising an error if its length is not exactly the given number of bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="gaeafa42ca3ae974494f127eb4b56ed8ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a bool. </p>
<p>Note that integers will raise mpack_error_type; the value must be strictly a bool. </p>

</div>
</div>
<a class="anchor" id="ga94489d03628c1fb1a3d0ac6971600fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the end. </p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or contains a null byte. </p>

</div>
</div>
<a class="anchor" id="gab6d2d920a0ed7d39e251ac8d6f077998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it has no null-bytes, and adds a null-terminator at the end. </p>
<p>You assume ownership of the returned pointer if reading succeeds.</p>
<p>The allocated string must be freed with MPACK_FREE() (or simply free() if MPack's allocator hasn't been customized.)</p>
<p>Raises mpack_error_too_big if the string plus null-terminator is larger than the given maxsize. Raises mpack_error_invalid if the value is not a string or contains a null byte. </p>

</div>
</div>
<a class="anchor" id="ga45a0891f890670e68efeaf1e0772d4b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED void mpack_expect_cstr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string, ensuring it exactly matches the given null-terminated string. </p>
<p>Remember that maps are unordered in JSON. Don't use this for map keys unless the map has only a single key! </p>

</div>
</div>
<a class="anchor" id="ga51a47ece249cd4d6d795bf3211fde745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, returning the value as a double. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a double.</p>
<p>Note that reading a very large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63f44e3d23db5e24d86b0b714f9ff95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, ensuring that it falls within the given range and returning the value as a double. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a double.</p>
<p>Note that reading a very large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad676ff64ce7933cade0c85da8a83799f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a double. </p>
<p>The underlying value must be a float or double, not an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float or double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa29ab364a7ae092e93a20b1a24744c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a bool, raising a mpack_error_type if it is not false. </p>

</div>
</div>
<a class="anchor" id="ga49c6bea0c4d7e14a636d703ffe304264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, returning the value as a float. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a float.</p>
<p>Note that reading a double or a large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0fffadf5032a669d582025f5131b53e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, ensuring that it falls within the given range and returning the value as a float. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a float.</p>
<p>Note that reading a double or a large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d56f4be6f5376ebfa6fcd0ebac6cce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a float. </p>
<p>The underlying value must be a float, not a double or an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8ef3886fd34471e00136a672b6cfbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga4ac3f09e7eb21aec1926aaff0ca37128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer, ensuring that it is at least zero and at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga6c4464418c0444854b3ab39785491a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaddca7f73951f581f0ddf03f6755322cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gacb9b77aa647947a1e47ab851c715cf6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer, ensuring that it is at least zero and at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga217f2065c5f039209f93cddbdbf01bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gad93d24fe9e68a1dd94054b70095ebcfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7354498073dfd3583db72591931d22a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer, ensuring that it is at least zero and at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7f7356f1e0638a076fac1a8db87f4f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga728dc9cb317871bbf3360361a713d471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga1436e08a6cb710bf11dabff20188f67b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer, ensuring that it is at least zero and at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaa553c386f7ad6d05423835d31a439461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gae81b9d03f80e49501c9b9a695489315f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_expect_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a signed int. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga8992b669afbaffee6ac8f336022611aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_int_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a signed integer, ensuring that it exactly matches the given value. </p>
<p>mpack_error_type is raised if the value is not representable as a signed integer or if it does not exactly match the given value. </p>

</div>
</div>
<a class="anchor" id="ga7a28a0a5daeeb9b4f10d2169d309f5eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_expect_int_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an int, ensuring that it is at least zero and at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga749d58ee5e884bce54b9767e7ee56c39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_expect_int_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga44a2941b8e8ec379748c238fab52bda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab66c8c170be1b394b397ccc041d6c133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_map_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map of the exact size given. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size does not match the given count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36d86c85877f94aa7b493aaa739c8849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map with a number of elements at most max_count, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</p>
<p>Zero is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2aae8867b092afd5a2350d4701687b35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_map_max_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of a map with a number of elements at most max_count, returning whether a map was read and placing its number of key/value pairs in count. </p>
<p>If a map was read, a number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> should anlso be called once all elements have been read (only if a map was read.)</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</p>
<dl class="section return"><dt>Returns</dt><dd>true if a map was read successfully; false if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee3ac5d2ea0dc864b5898673a67c69ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_map_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of a map, returning whether a map was read and placing its number of key/value pairs in count. </p>
<p>If a map was read, a number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> should also be called once all elements have been read (only if a map was read.)</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</p>
<dl class="section return"><dt>Returns</dt><dd>true if a map was read successfully; false if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2d131161862c386e9f048ad93fb3d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map with a number of elements in the given range, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</p>
<p>min_count is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada69acbd6803f79cab7573ae9ebc37bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil. </p>

</div>
</div>
<a class="anchor" id="ga6baba88194988c9f423630052d59f7fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, returning its size in bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string. </p>

</div>
</div>
<a class="anchor" id="ga0d720d03002423e764c55b9370d89caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_str_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string with the given total maximum size, allocating storage for it. </p>
<p>The length in bytes of the string will be written to size if reading is successful; otherwise size will be zero.</p>
<p>The allocated string must be freed with MPACK_FREE() (or simply free() if MPack's allocator hasn't been customized.)</p>
<p>No null-terminator will be added to the string. Use <a class="el" href="group__expect.html#gab6d2d920a0ed7d39e251ac8d6f077998">mpack_expect_cstr_alloc()</a> if you want a null-terminator.</p>
<p>Returns NULL if any error occurs. </p>

</div>
</div>
<a class="anchor" id="ga658205c994cf8fce528f4c8a3a957a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_str_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string of at most the given size, writing it into the given buffer and returning its size in bytes. </p>
<p>Note that this does not add a null-terminator! No null-terminator is written, even if the string fits. Use <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8" title="Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the...">mpack_expect_cstr()</a> to get a null-terminator. </p>

</div>
</div>
<a class="anchor" id="ga2125706c0ccfa05074f2a0551fbf2cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED void mpack_expect_str_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, raising an error if its length is not exactly the given number of bytes (not including any null-terminator.) </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="ga3ceade6375ab699c1ef05ef9f5c2ff90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_str_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string, ensuring it exactly matches the given string. </p>
<p>Remember that maps are unordered in JSON. Don't use this for map keys unless the map has only a single key! </p>

</div>
</div>
<a class="anchor" id="gaea5d6e47485092366b64d7667fc93916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED uint32_t mpack_expect_str_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, raising an error if its length is not at most the given number of bytes (not including any null-terminator.) </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="ga6e9c48430fa233615ec9b5439f9ed451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#structmpack__tag__t">mpack_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a MessagePack object header (an MPack tag), expecting it to exactly match the given tag. </p>
<p>If the type is compound (i.e. is a map, array, string, binary or extension type), additional reads are required to get the actual data, and the corresponding done function (or cancel) should be called when done.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the tag does not match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06" title="Finishes reading an array. ">mpack_done_array()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a" title="Finishes reading a map. ">mpack_done_map()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6" title="Finishes reading a string. ">mpack_done_str()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0" title="Finishes reading a binary data blob. ">mpack_done_bin()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga5ebed90f6fe9c1d324256d827032702b" title="Finishes reading an extended type binary data blob. ">mpack_done_ext()</a> </dd>
<dd>
mpack_cancel() </dd></dl>

</div>
</div>
<a class="anchor" id="gaadfca446696881a598cc4f90892ded88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a bool, raising a mpack_error_type if it is not true. </p>

</div>
</div>
<a class="anchor" id="gad267aebef43d94bc7891939d1fc2d51a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga34cfd4d43ba388ff4f983b35c65c669a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer, ensuring that it is at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gad6f984713bc3b24b044a99cd6f4e58b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaccb728859e5944214324a23979fe0aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga4781e89d1712ae950b768362b8e98065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer, ensuring that it is at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab2dbbc0830bc08f2e7ce851782ec06e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gac5babd6ebf912abb4ed67ca8808f3ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer, ensuring that it is at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7110dc658b713b292e9cafee3ccb7424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab1310dc54c39ac7754ee62d635a82976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga61459cbdd02c5b3db5292f9753a03ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer, ensuring that it is at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab3922088844e8cb301a6c2a5c5750d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab217c0e2062b87129f948c6359c3825a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_expect_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned int. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga005303e0b2c39809fcd5172228fae282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_uint_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned integer, ensuring that it exactly matches the given value. </p>
<p>mpack_error_type is raised if the value is not representable as an unsigned integer or if it does not exactly match the given value. </p>

</div>
</div>
<a class="anchor" id="ga279a98fc2bb44cbf837fafc70df35bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_expect_uint_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned integer, ensuring that it is at most max_value. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaa42508b6153a3531961eb69c38d48bbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_expect_uint_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga8c44c450649514ee1a31e567d39f0bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensuring it is a valid UTF-8 string and returning its size in bytes. </p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p>Raises mpack_error_too_big if there is not enough room for the string. Raises mpack_error_type if the value is not a string or is not a valid UTF-8 string. </p>

</div>
</div>
<a class="anchor" id="ga7079e453f462184ada877d68816d59e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_utf8_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string with the given total maximum size, allocating storage for it and ensuring it is valid UTF-8. </p>
<p>The length in bytes of the string, not including the null-terminator, will be written to size.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p>The allocated string must be freed with MPACK_FREE() (or simply free() if MPack's allocator hasn't been customized.)</p>
<p>No null-terminator will be added to the string. Use <a class="el" href="group__expect.html#gab6d2d920a0ed7d39e251ac8d6f077998">mpack_expect_cstr_alloc()</a> if you want a null-terminator. </p>

</div>
</div>
<a class="anchor" id="ga62be63032f3c84181eeed4609f0dddb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensures it is a valid UTF-8 string without null characters, and adds a null-terminator at the end. </p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed, but without the null character, since it cannot be represented in a null-terminated string.</p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or is not a valid UTF-8 string. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
