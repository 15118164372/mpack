<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>MPack: Expect API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPack
   &#160;<span id="projectnumber">0.6</span>
   </div>
   <div id="projectbrief">A C encoding/decoding library for the MessagePack serialization format.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Expect API</div>  </div>
</div><!--header-->
<div class="contents">

<p>The MPack Expect API allows you to easily read MessagePack data when you expect it to follow a predefined schema.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic Number Functions</h2></td></tr>
<tr class="memitem:gab1310dc54c39ac7754ee62d635a82976"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab1310dc54c39ac7754ee62d635a82976">mpack_expect_u8</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab1310dc54c39ac7754ee62d635a82976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer.  <a href="#gab1310dc54c39ac7754ee62d635a82976">More...</a><br /></td></tr>
<tr class="separator:gab1310dc54c39ac7754ee62d635a82976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad267aebef43d94bc7891939d1fc2d51a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad267aebef43d94bc7891939d1fc2d51a">mpack_expect_u16</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad267aebef43d94bc7891939d1fc2d51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer.  <a href="#gad267aebef43d94bc7891939d1fc2d51a">More...</a><br /></td></tr>
<tr class="separator:gad267aebef43d94bc7891939d1fc2d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb728859e5944214324a23979fe0aa2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaccb728859e5944214324a23979fe0aa2">mpack_expect_u32</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaccb728859e5944214324a23979fe0aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer.  <a href="#gaccb728859e5944214324a23979fe0aa2">More...</a><br /></td></tr>
<tr class="separator:gaccb728859e5944214324a23979fe0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab2dbbc0830bc08f2e7ce851782ec06e5">mpack_expect_u64</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer.  <a href="#gab2dbbc0830bc08f2e7ce851782ec06e5">More...</a><br /></td></tr>
<tr class="separator:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728dc9cb317871bbf3360361a713d471"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga728dc9cb317871bbf3360361a713d471">mpack_expect_i8</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga728dc9cb317871bbf3360361a713d471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer.  <a href="#ga728dc9cb317871bbf3360361a713d471">More...</a><br /></td></tr>
<tr class="separator:ga728dc9cb317871bbf3360361a713d471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad8ef3886fd34471e00136a672b6cfbfa">mpack_expect_i16</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad8ef3886fd34471e00136a672b6cfbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer.  <a href="#gad8ef3886fd34471e00136a672b6cfbfa">More...</a><br /></td></tr>
<tr class="separator:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddca7f73951f581f0ddf03f6755322cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaddca7f73951f581f0ddf03f6755322cf">mpack_expect_i32</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaddca7f73951f581f0ddf03f6755322cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer.  <a href="#gaddca7f73951f581f0ddf03f6755322cf">More...</a><br /></td></tr>
<tr class="separator:gaddca7f73951f581f0ddf03f6755322cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad93d24fe9e68a1dd94054b70095ebcfb">mpack_expect_i64</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer.  <a href="#gad93d24fe9e68a1dd94054b70095ebcfb">More...</a><br /></td></tr>
<tr class="separator:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga49c6bea0c4d7e14a636d703ffe304264">mpack_expect_float</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga49c6bea0c4d7e14a636d703ffe304264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, returning the value as a float.  <a href="#ga49c6bea0c4d7e14a636d703ffe304264">More...</a><br /></td></tr>
<tr class="separator:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a47ece249cd4d6d795bf3211fde745"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga51a47ece249cd4d6d795bf3211fde745">mpack_expect_double</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga51a47ece249cd4d6d795bf3211fde745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, returning the value as a double.  <a href="#ga51a47ece249cd4d6d795bf3211fde745">More...</a><br /></td></tr>
<tr class="separator:ga51a47ece249cd4d6d795bf3211fde745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">mpack_expect_float_strict</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a float.  <a href="#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">More...</a><br /></td></tr>
<tr class="separator:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad676ff64ce7933cade0c85da8a83799f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad676ff64ce7933cade0c85da8a83799f">mpack_expect_double_strict</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad676ff64ce7933cade0c85da8a83799f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a double.  <a href="#gad676ff64ce7933cade0c85da8a83799f">More...</a><br /></td></tr>
<tr class="separator:gad676ff64ce7933cade0c85da8a83799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ranged Number Functions</h2></td></tr>
<tr class="memitem:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab3922088844e8cb301a6c2a5c5750d4f">mpack_expect_u8_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint8_t min_value, uint8_t max_value)</td></tr>
<tr class="memdesc:gab3922088844e8cb301a6c2a5c5750d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer, ensuring that it falls within the given range.  <a href="#gab3922088844e8cb301a6c2a5c5750d4f">More...</a><br /></td></tr>
<tr class="separator:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad6f984713bc3b24b044a99cd6f4e58b7">mpack_expect_u16_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint16_t min_value, uint16_t max_value)</td></tr>
<tr class="memdesc:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer, ensuring that it falls within the given range.  <a href="#gad6f984713bc3b24b044a99cd6f4e58b7">More...</a><br /></td></tr>
<tr class="separator:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">mpack_expect_u32_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t min_value, uint32_t max_value)</td></tr>
<tr class="memdesc:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer, ensuring that it falls within the given range.  <a href="#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">More...</a><br /></td></tr>
<tr class="separator:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7110dc658b713b292e9cafee3ccb7424"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7110dc658b713b292e9cafee3ccb7424">mpack_expect_u64_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint64_t min_value, uint64_t max_value)</td></tr>
<tr class="memdesc:ga7110dc658b713b292e9cafee3ccb7424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer, ensuring that it falls within the given range.  <a href="#ga7110dc658b713b292e9cafee3ccb7424">More...</a><br /></td></tr>
<tr class="separator:ga7110dc658b713b292e9cafee3ccb7424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61459cbdd02c5b3db5292f9753a03ced"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga61459cbdd02c5b3db5292f9753a03ced"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_u8_max</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint8_t max_value)</td></tr>
<tr class="separator:ga61459cbdd02c5b3db5292f9753a03ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34cfd4d43ba388ff4f983b35c65c669a"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_u16_max</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint16_t max_value)</td></tr>
<tr class="separator:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4781e89d1712ae950b768362b8e98065"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4781e89d1712ae950b768362b8e98065"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_u32_max</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t max_value)</td></tr>
<tr class="separator:ga4781e89d1712ae950b768362b8e98065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5babd6ebf912abb4ed67ca8808f3ad0"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_u64_max</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint64_t max_value)</td></tr>
<tr class="separator:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa553c386f7ad6d05423835d31a439461"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa553c386f7ad6d05423835d31a439461">mpack_expect_i8_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int8_t min_value, int8_t max_value)</td></tr>
<tr class="memdesc:gaa553c386f7ad6d05423835d31a439461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer, ensuring that it falls within the given range.  <a href="#gaa553c386f7ad6d05423835d31a439461">More...</a><br /></td></tr>
<tr class="separator:gaa553c386f7ad6d05423835d31a439461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4464418c0444854b3ab39785491a4b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6c4464418c0444854b3ab39785491a4b">mpack_expect_i16_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int16_t min_value, int16_t max_value)</td></tr>
<tr class="memdesc:ga6c4464418c0444854b3ab39785491a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer, ensuring that it falls within the given range.  <a href="#ga6c4464418c0444854b3ab39785491a4b">More...</a><br /></td></tr>
<tr class="separator:ga6c4464418c0444854b3ab39785491a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217f2065c5f039209f93cddbdbf01bee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga217f2065c5f039209f93cddbdbf01bee">mpack_expect_i32_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int32_t min_value, int32_t max_value)</td></tr>
<tr class="memdesc:ga217f2065c5f039209f93cddbdbf01bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer, ensuring that it falls within the given range.  <a href="#ga217f2065c5f039209f93cddbdbf01bee">More...</a><br /></td></tr>
<tr class="separator:ga217f2065c5f039209f93cddbdbf01bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7f7356f1e0638a076fac1a8db87f4f53">mpack_expect_i64_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int64_t min_value, int64_t max_value)</td></tr>
<tr class="memdesc:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer, ensuring that it falls within the given range.  <a href="#ga7f7356f1e0638a076fac1a8db87f4f53">More...</a><br /></td></tr>
<tr class="separator:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fffadf5032a669d582025f5131b53e2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0fffadf5032a669d582025f5131b53e2">mpack_expect_float_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, float min_value, float max_value)</td></tr>
<tr class="memdesc:ga0fffadf5032a669d582025f5131b53e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, ensuring that it falls within the given range and returning the value as a float.  <a href="#ga0fffadf5032a669d582025f5131b53e2">More...</a><br /></td></tr>
<tr class="separator:ga0fffadf5032a669d582025f5131b53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga63f44e3d23db5e24d86b0b714f9ff95b">mpack_expect_double_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, double min_value, double max_value)</td></tr>
<tr class="memdesc:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, ensuring that it falls within the given range and returning the value as a double.  <a href="#ga63f44e3d23db5e24d86b0b714f9ff95b">More...</a><br /></td></tr>
<tr class="separator:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Matching Number Functions</h2></td></tr>
<tr class="memitem:ga005303e0b2c39809fcd5172228fae282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga005303e0b2c39809fcd5172228fae282">mpack_expect_uint_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint64_t value)</td></tr>
<tr class="memdesc:ga005303e0b2c39809fcd5172228fae282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned integer, ensuring that it exactly matches the given value.  <a href="#ga005303e0b2c39809fcd5172228fae282">More...</a><br /></td></tr>
<tr class="separator:ga005303e0b2c39809fcd5172228fae282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8992b669afbaffee6ac8f336022611aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8992b669afbaffee6ac8f336022611aa">mpack_expect_int_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, int64_t value)</td></tr>
<tr class="memdesc:ga8992b669afbaffee6ac8f336022611aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed integer, ensuring that it exactly matches the given value.  <a href="#ga8992b669afbaffee6ac8f336022611aa">More...</a><br /></td></tr>
<tr class="separator:ga8992b669afbaffee6ac8f336022611aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Other Basic Types</h2></td></tr>
<tr class="memitem:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gada69acbd6803f79cab7573ae9ebc37bd">mpack_expect_nil</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gada69acbd6803f79cab7573ae9ebc37bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil.  <a href="#gada69acbd6803f79cab7573ae9ebc37bd">More...</a><br /></td></tr>
<tr class="separator:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaeafa42ca3ae974494f127eb4b56ed8ae">mpack_expect_bool</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a bool.  <a href="#gaeafa42ca3ae974494f127eb4b56ed8ae">More...</a><br /></td></tr>
<tr class="separator:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfca446696881a598cc4f90892ded88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaadfca446696881a598cc4f90892ded88">mpack_expect_true</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaadfca446696881a598cc4f90892ded88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a bool, raising a mpack_error_type if it is not true.  <a href="#gaadfca446696881a598cc4f90892ded88">More...</a><br /></td></tr>
<tr class="separator:gaadfca446696881a598cc4f90892ded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa29ab364a7ae092e93a20b1a24744c0e">mpack_expect_false</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a bool, raising a mpack_error_type if it is not false.  <a href="#gaa29ab364a7ae092e93a20b1a24744c0e">More...</a><br /></td></tr>
<tr class="separator:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compound Types</h2></td></tr>
<tr class="memitem:ga44a2941b8e8ec379748c238fab52bda1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga44a2941b8e8ec379748c238fab52bda1">mpack_expect_map</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga44a2941b8e8ec379748c238fab52bda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map, returning its element count.  <a href="#ga44a2941b8e8ec379748c238fab52bda1">More...</a><br /></td></tr>
<tr class="separator:ga44a2941b8e8ec379748c238fab52bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d131161862c386e9f048ad93fb3d45"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa2d131161862c386e9f048ad93fb3d45">mpack_expect_map_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="memdesc:gaa2d131161862c386e9f048ad93fb3d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map with a number of elements in the given range, returning its element count.  <a href="#gaa2d131161862c386e9f048ad93fb3d45">More...</a><br /></td></tr>
<tr class="separator:gaa2d131161862c386e9f048ad93fb3d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66c8c170be1b394b397ccc041d6c133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab66c8c170be1b394b397ccc041d6c133">mpack_expect_map_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:gab66c8c170be1b394b397ccc041d6c133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map of the exact size given.  <a href="#gab66c8c170be1b394b397ccc041d6c133">More...</a><br /></td></tr>
<tr class="separator:gab66c8c170be1b394b397ccc041d6c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee3ac5d2ea0dc864b5898673a67c69ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_map_or_nil</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t *count)</td></tr>
<tr class="separator:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18285492fd04458fb7ab0d151bea0402"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga18285492fd04458fb7ab0d151bea0402">mpack_expect_array</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga18285492fd04458fb7ab0d151bea0402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array, returning its element count.  <a href="#ga18285492fd04458fb7ab0d151bea0402">More...</a><br /></td></tr>
<tr class="separator:ga18285492fd04458fb7ab0d151bea0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0b7dd785576183e5444691c7d32b90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4c0b7dd785576183e5444691c7d32b90">mpack_expect_array_range</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="memdesc:ga4c0b7dd785576183e5444691c7d32b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array with a number of elements in the given range, returning its element count.  <a href="#ga4c0b7dd785576183e5444691c7d32b90">More...</a><br /></td></tr>
<tr class="separator:ga4c0b7dd785576183e5444691c7d32b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1599675ca83c5c03af8de220b9a826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e1599675ca83c5c03af8de220b9a826"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_array_max</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t max_count)</td></tr>
<tr class="separator:ga3e1599675ca83c5c03af8de220b9a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga799bb820a49f5a8a70e604466f8ab9b5">mpack_expect_array_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array of the exact size given.  <a href="#ga799bb820a49f5a8a70e604466f8ab9b5">More...</a><br /></td></tr>
<tr class="separator:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d80bf47c6b2deb5cfa607998fd2c58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga98d80bf47c6b2deb5cfa607998fd2c58">mpack_expect_array_alloc</a>(reader,  Type,  max_count,  count)</td></tr>
<tr class="memdesc:ga98d80bf47c6b2deb5cfa607998fd2c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array and allocates storage for it, placing its size in count.  <a href="#ga98d80bf47c6b2deb5cfa607998fd2c58">More...</a><br /></td></tr>
<tr class="separator:ga98d80bf47c6b2deb5cfa607998fd2c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
String Functions</h2></td></tr>
<tr class="memitem:ga6baba88194988c9f423630052d59f7fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga6baba88194988c9f423630052d59f7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, returning its size in bytes.  <a href="#ga6baba88194988c9f423630052d59f7fd">More...</a><br /></td></tr>
<tr class="separator:ga6baba88194988c9f423630052d59f7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658205c994cf8fce528f4c8a3a957a14"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga658205c994cf8fce528f4c8a3a957a14">mpack_expect_str_buf</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t bufsize)</td></tr>
<tr class="memdesc:ga658205c994cf8fce528f4c8a3a957a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string of at most the given size, writing it into the given buffer and returning its size in bytes.  <a href="#ga658205c994cf8fce528f4c8a3a957a14">More...</a><br /></td></tr>
<tr class="separator:ga658205c994cf8fce528f4c8a3a957a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b096b7fb963f522305ebaeafc777dd6"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4b096b7fb963f522305ebaeafc777dd6">mpack_expect_str_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="memdesc:ga4b096b7fb963f522305ebaeafc777dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, raising an error if its length is not at most the given number of bytes (not including any null-terminator.)  <a href="#ga4b096b7fb963f522305ebaeafc777dd6">More...</a><br /></td></tr>
<tr class="separator:ga4b096b7fb963f522305ebaeafc777dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2125706c0ccfa05074f2a0551fbf2cf1"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2125706c0ccfa05074f2a0551fbf2cf1">mpack_expect_str_length</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:ga2125706c0ccfa05074f2a0551fbf2cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, raising an error if its length is not exactly the given number of bytes (not including any null-terminator.)  <a href="#ga2125706c0ccfa05074f2a0551fbf2cf1">More...</a><br /></td></tr>
<tr class="separator:ga2125706c0ccfa05074f2a0551fbf2cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d720d03002423e764c55b9370d89caf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0d720d03002423e764c55b9370d89caf">mpack_expect_str_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:ga0d720d03002423e764c55b9370d89caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string with the given total maximum size, allocating storage for it.  <a href="#ga0d720d03002423e764c55b9370d89caf">More...</a><br /></td></tr>
<tr class="separator:ga0d720d03002423e764c55b9370d89caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7079e453f462184ada877d68816d59e3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7079e453f462184ada877d68816d59e3">mpack_expect_utf8_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:ga7079e453f462184ada877d68816d59e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string with the given total maximum size, allocating storage for it and ensuring it is valid UTF-8.  <a href="#ga7079e453f462184ada877d68816d59e3">More...</a><br /></td></tr>
<tr class="separator:ga7079e453f462184ada877d68816d59e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensures it has no null-bytes, and adds null-terminator at the end.  <a href="#ga94489d03628c1fb1a3d0ac6971600fe8">More...</a><br /></td></tr>
<tr class="separator:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62be63032f3c84181eeed4609f0dddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga62be63032f3c84181eeed4609f0dddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensures it is a valid UTF-8 string, and adds null-terminator at the end.  <a href="#ga62be63032f3c84181eeed4609f0dddb4">More...</a><br /></td></tr>
<tr class="separator:ga62be63032f3c84181eeed4609f0dddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab6d2d920a0ed7d39e251ac8d6f077998">mpack_expect_cstr_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize)</td></tr>
<tr class="memdesc:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string, allocates storage for it, ensures it has no null-bytes, and adds null-terminator at the end.  <a href="#gab6d2d920a0ed7d39e251ac8d6f077998">More...</a><br /></td></tr>
<tr class="separator:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f16d7ec771277e1be2a35ea0573db31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8f16d7ec771277e1be2a35ea0573db31">mpack_expect_cstr_match</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, const char *str)</td></tr>
<tr class="memdesc:ga8f16d7ec771277e1be2a35ea0573db31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string, ensuring it exactly matches the given null-terminated string.  <a href="#ga8f16d7ec771277e1be2a35ea0573db31">More...</a><br /></td></tr>
<tr class="separator:ga8f16d7ec771277e1be2a35ea0573db31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Binary Data / Extension Functions</h2></td></tr>
<tr class="memitem:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5">mpack_expect_bin</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, returning its size in bytes.  <a href="#gadcf7fc94ae30ed5c3752291a0efd43c5">More...</a><br /></td></tr>
<tr class="separator:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc38a1a41ea8f64f639c565050831a1"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1fc38a1a41ea8f64f639c565050831a1">mpack_expect_bin_max</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="memdesc:ga1fc38a1a41ea8f64f639c565050831a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, raising an error if its length is not at most the given number of bytes.  <a href="#ga1fc38a1a41ea8f64f639c565050831a1">More...</a><br /></td></tr>
<tr class="separator:ga1fc38a1a41ea8f64f639c565050831a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8202406ef14871b82ee0b4f3a1da21"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE_SPEED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gace8202406ef14871b82ee0b4f3a1da21">mpack_expect_bin_size</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:gace8202406ef14871b82ee0b4f3a1da21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, raising an error if its length is not exactly the given number of bytes.  <a href="#gace8202406ef14871b82ee0b4f3a1da21">More...</a><br /></td></tr>
<tr class="separator:gace8202406ef14871b82ee0b4f3a1da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga98004c26b9ebc1b80b4bdec5a1d4b093">mpack_expect_bin_buf</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a binary blob into the given buffer, returning its size in bytes.  <a href="#ga98004c26b9ebc1b80b4bdec5a1d4b093">More...</a><br /></td></tr>
<tr class="separator:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2745fe313f15c619a9a44f8dc79a3777"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2745fe313f15c619a9a44f8dc79a3777"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_expect_bin_inplace</b> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="separator:ga2745fe313f15c619a9a44f8dc79a3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga513a9ce0e5bf78128d2d174bf1434538">mpack_expect_bin_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:ga513a9ce0e5bf78128d2d174bf1434538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a binary blob with the given total maximum size, allocating storage for it.  <a href="#ga513a9ce0e5bf78128d2d174bf1434538">More...</a><br /></td></tr>
<tr class="separator:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d27dd1c1011dc33505d1b6f8ee2b7e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga29d27dd1c1011dc33505d1b6f8ee2b7e">mpack_expect_ext_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, size_t maxsize, uint8_t *exttype, size_t *size)</td></tr>
<tr class="memdesc:ga29d27dd1c1011dc33505d1b6f8ee2b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an extension object with the given total maximum size, allocating storage for it.  <a href="#ga29d27dd1c1011dc33505d1b6f8ee2b7e">More...</a><br /></td></tr>
<tr class="separator:ga29d27dd1c1011dc33505d1b6f8ee2b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b6ffdd8babbe74664003a4fad2f83f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab9b6ffdd8babbe74664003a4fad2f83f">mpack_expect_ext_type_alloc</a> (<a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *reader, uint8_t exttype, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:gab9b6ffdd8babbe74664003a4fad2f83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an extension object of the given type with the given total maximum size, allocating storage for it.  <a href="#gab9b6ffdd8babbe74664003a4fad2f83f">More...</a><br /></td></tr>
<tr class="separator:gab9b6ffdd8babbe74664003a4fad2f83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The MPack Expect API allows you to easily read MessagePack data when you expect it to follow a predefined schema. </p>
<p>The main purpose of the Expect API is convenience, so the API is lax. It allows overlong / inefficiently encoded sequences, and it automatically converts between similar types where there is no loss of precision (unless otherwise noted.) It will convert from unsigned to signed or from float to double for example.</p>
<p>When using any of the expect functions, if the type or value of what was read does not match what is expected, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga98d80bf47c6b2deb5cfa607998fd2c58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_expect_array_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array and allocates storage for it, placing its size in count. </p>
<p>A number of objects follow equal to the element count of the array. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga18285492fd04458fb7ab0d151bea0402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read. </p>

</div>
</div>
<a class="anchor" id="ga799bb820a49f5a8a70e604466f8ab9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_array_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array of the exact size given. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c0b7dd785576183e5444691c7d32b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array with a number of elements in the given range, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadcf7fc94ae30ed5c3752291a0efd43c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, returning its size in bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob. </p>

</div>
</div>
<a class="anchor" id="ga513a9ce0e5bf78128d2d174bf1434538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_bin_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a binary blob with the given total maximum size, allocating storage for it. </p>

</div>
</div>
<a class="anchor" id="ga98004c26b9ebc1b80b4bdec5a1d4b093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_bin_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a binary blob into the given buffer, returning its size in bytes. </p>
<p>For compatibility, this will accept if the underlying type is string or binary (since in MessagePack 1.0, strings and binary data were combined under the "raw" type which became string in 1.1.) </p>

</div>
</div>
<a class="anchor" id="ga1fc38a1a41ea8f64f639c565050831a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED void mpack_expect_bin_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, raising an error if its length is not at most the given number of bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="gace8202406ef14871b82ee0b4f3a1da21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED void mpack_expect_bin_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, raising an error if its length is not exactly the given number of bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="gaeafa42ca3ae974494f127eb4b56ed8ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a bool. </p>
<p>Note that integers will raise mpack_error_type; the value must be strictly a bool. </p>

</div>
</div>
<a class="anchor" id="ga94489d03628c1fb1a3d0ac6971600fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensures it has no null-bytes, and adds null-terminator at the end. </p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or contains a null byte. </p>

</div>
</div>
<a class="anchor" id="gab6d2d920a0ed7d39e251ac8d6f077998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string, allocates storage for it, ensures it has no null-bytes, and adds null-terminator at the end. </p>
<p>You assume ownership of the returned pointer if reading succeeds.</p>
<p>Raises mpack_error_too_big if the string plus null-terminator is larger than the given maxsize. Raises mpack_error_invalid if the value is not a string or contains a null byte. </p>

</div>
</div>
<a class="anchor" id="ga8f16d7ec771277e1be2a35ea0573db31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_cstr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string, ensuring it exactly matches the given null-terminated string. </p>
<p>Remember that maps are unordered in JSON. Don't use this for map keys unless the map has only a single key! </p>

</div>
</div>
<a class="anchor" id="ga51a47ece249cd4d6d795bf3211fde745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, returning the value as a double. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a double.</p>
<p>Note that reading a very large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63f44e3d23db5e24d86b0b714f9ff95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, ensuring that it falls within the given range and returning the value as a double. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a double.</p>
<p>Note that reading a very large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad676ff64ce7933cade0c85da8a83799f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a double. </p>
<p>The underlying value must be a float or double, not an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float or double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga29d27dd1c1011dc33505d1b6f8ee2b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_ext_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>exttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an extension object with the given total maximum size, allocating storage for it. </p>
<p>The extension type will be written to exttype, and the size will be written to size. </p>

</div>
</div>
<a class="anchor" id="gab9b6ffdd8babbe74664003a4fad2f83f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_ext_type_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>exttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an extension object of the given type with the given total maximum size, allocating storage for it. </p>
<p>The size will be written to size. </p>

</div>
</div>
<a class="anchor" id="gaa29ab364a7ae092e93a20b1a24744c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a bool, raising a mpack_error_type if it is not false. </p>

</div>
</div>
<a class="anchor" id="ga49c6bea0c4d7e14a636d703ffe304264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, returning the value as a float. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a float.</p>
<p>Note that reading a double or a large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0fffadf5032a669d582025f5131b53e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, ensuring that it falls within the given range and returning the value as a float. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a float.</p>
<p>Note that reading a double or a large integer with this function can incur a loss of precision.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d56f4be6f5376ebfa6fcd0ebac6cce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a float. </p>
<p>The underlying value must be a float, not a double or an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8ef3886fd34471e00136a672b6cfbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga6c4464418c0444854b3ab39785491a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaddca7f73951f581f0ddf03f6755322cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga217f2065c5f039209f93cddbdbf01bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gad93d24fe9e68a1dd94054b70095ebcfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7f7356f1e0638a076fac1a8db87f4f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga728dc9cb317871bbf3360361a713d471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaa553c386f7ad6d05423835d31a439461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga8992b669afbaffee6ac8f336022611aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_int_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a signed integer, ensuring that it exactly matches the given value. </p>
<p>mpack_error_type is raised if the value is not representable as a signed integer or if it does not exactly match the given value. </p>

</div>
</div>
<a class="anchor" id="ga44a2941b8e8ec379748c238fab52bda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<p>mpack_error_type is raised if the value is not a map.</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON. </p>

</div>
</div>
<a class="anchor" id="gab66c8c170be1b394b397ccc041d6c133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_map_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map of the exact size given. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<p><a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised if the value is not a map or if its size does not match the given count.</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON. </p>

</div>
</div>
<a class="anchor" id="gaa2d131161862c386e9f048ad93fb3d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map with a number of elements in the given range, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<p>mpack_error_type is raised if the value is not a map or if its size does not fall within the given range.</p>
<p>Note that maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON. </p>

</div>
</div>
<a class="anchor" id="gada69acbd6803f79cab7573ae9ebc37bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil. </p>

</div>
</div>
<a class="anchor" id="ga6baba88194988c9f423630052d59f7fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, returning its size in bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string. </p>

</div>
</div>
<a class="anchor" id="ga0d720d03002423e764c55b9370d89caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_str_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string with the given total maximum size, allocating storage for it. </p>
<p>A null-terminator will be added to the string. The length in bytes of the string, not including the null-terminator, will be written to size. </p>

</div>
</div>
<a class="anchor" id="ga658205c994cf8fce528f4c8a3a957a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_str_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string of at most the given size, writing it into the given buffer and returning its size in bytes. </p>
<p>Note that this does not add a null-terminator! No null-terminator is written, even if the string fits. Use <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8" title="Reads a string into the given buffer, ensures it has no null-bytes, and adds null-terminator at the e...">mpack_expect_cstr()</a> to get a null-terminator. </p>

</div>
</div>
<a class="anchor" id="ga2125706c0ccfa05074f2a0551fbf2cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED void mpack_expect_str_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, raising an error if its length is not exactly the given number of bytes (not including any null-terminator.) </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="ga4b096b7fb963f522305ebaeafc777dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE_SPEED void mpack_expect_str_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, raising an error if its length is not at most the given number of bytes (not including any null-terminator.) </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object. ">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="gaadfca446696881a598cc4f90892ded88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a bool, raising a mpack_error_type if it is not true. </p>

</div>
</div>
<a class="anchor" id="gad267aebef43d94bc7891939d1fc2d51a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gad6f984713bc3b24b044a99cd6f4e58b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaccb728859e5944214324a23979fe0aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab2dbbc0830bc08f2e7ce851782ec06e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7110dc658b713b292e9cafee3ccb7424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab1310dc54c39ac7754ee62d635a82976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab3922088844e8cb301a6c2a5c5750d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga005303e0b2c39809fcd5172228fae282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_uint_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned integer, ensuring that it exactly matches the given value. </p>
<p>mpack_error_type is raised if the value is not representable as an unsigned integer or if it does not exactly match the given value. </p>

</div>
</div>
<a class="anchor" id="ga7079e453f462184ada877d68816d59e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_utf8_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string with the given total maximum size, allocating storage for it and ensuring it is valid UTF-8. </p>
<p>A null-terminator will be added to the string. The length in bytes of the string, not including the null-terminator, will be written to size. </p>

</div>
</div>
<a class="anchor" id="ga62be63032f3c84181eeed4609f0dddb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#structmpack__reader__t">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensures it is a valid UTF-8 string, and adds null-terminator at the end. </p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or is not a valid UTF-8 string. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
